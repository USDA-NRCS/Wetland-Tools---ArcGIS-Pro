aprx = arcpy.mp.ArcGISProject("CURRENT")
activeMap = aprx.activeMap
activeMapName = activeMap.name
activeMapName
activeMapSR = activeMap.getDefinition('V2').spatialReference['latestWkid']
activeMapSR
outSpatialRef = arcpy.SpatialReference(activeMapSR)
outSpatialRef
outSpatialRef.name
import urllib
from urllib.request import Reqeust, urlopen
from urllib.request import Request, urlopen
from urllib.error import HTTPError as httErrors
urllibEncode = urllib.parse.urlencode
urllilbEncode
urllibEncode
parseQueryString = urllib.parse.parse_qsl
cluRESTurl_Metadata = """https://gis.sc.egov.usda.gov/appserver/rest/services/common_land_units/common_land_units/FeatureServer/0"""
cluRESTurl_Metadata
params = urllibEncode({'f': 'json','token': portalToken['token']})
nrcsPortal = 'https://gis.sc.egov.usda.gov/portal/'
nrcsPortal
def getPortalTokenInfo(portalURL):     try:         # Returns the URL of the active Portal         # i.e. 'https://gis.sc.egov.usda.gov/portal/'         activePortal = arcpy.GetActivePortalURL()          # {'SSL_enabled': False, 'portal_version': 6.1, 'role': '', 'organization': '', 'organization_type': ''}         #portalInfo = arcpy.GetPortalInfo(activePortal)          # targeted portal is NOT set as default         if activePortal != portalURL:                 # List of managed portals                managedPortals = arcpy.ListPortalURLs()                 # portalURL is available in managed list                if activePortal in managedPortals:                    AddMsgAndPrint("\nYour Active portal is set to: " + activePortal,2)                    AddMsgAndPrint("Set your active portal and sign into: " + portalURL,2)                    return False                 # portalURL must first be added to list of managed portals                else:                     AddMsgAndPrint("\nYou must add " + portalURL + " to your list of managed portals",2)                     AddMsgAndPrint("Open the Portals Tab to manage portal connections",2)                     AddMsgAndPrint("For more information visit the following ArcGIS Pro documentation:",2)                     AddMsgAndPrint("https://pro.arcgis.com/en/pro-app/help/projects/manage-portal-connections-from-arcgis-pro.htm",1)                     return False          # targeted Portal is correct; try to generate token         else:              # Get Token information             tokenInfo = arcpy.GetSigninToken()              # Not signed in.  Token results are empty             if not tokenInfo:                 AddMsgAndPrint("\nYou are not signed into: " + portalURL,2)                 return False              # Token generated successfully             else:                 return tokenInfo      except:         errorMsg()         return False
portalToken = getPortalTokenInfo(nrcsPortal)
params = urllibEncode({'f': 'json','token': portalToken['token']})
params
def submitFSquery(url,INparams):     # This function will send a spatial query to a web feature service and convert the results into a python     # structure.  If the results from the service is an error due to an invalid token then a second attempt will     # be sent with using a newly generated arcgis token.  If the token is good but the request returned with an     # error a second attempt will be made.  The function takes in 2 parameters, the URL to the web service and a     # query string in URLencoded format.      # Error produced with invalid token     # {u'error': {u'code': 498, u'details': [], u'message': u'Invalid Token'}}      # The function returns requested data via a python dictionary      try:         # Data should be in bytes; new in Python 3.6         INparams = INparams.encode('ascii')         resp = urllib.request.urlopen(url,INparams)  # A failure here will probably throw an HTTP exception         responseStatus = resp.getcode()         responseMsg = resp.msg         jsonString = resp.read()          # json --> Python; dictionary containing 1 key with a list of lists         results = json.loads(jsonString)          # Check for expired token; Update if expired and try again         if 'error' in results.keys():             if results['error']['message'] == 'Invalid Token':                 AddMsgAndPrint("\tRegenerating ArcGIS Token Information...")                  # Get new ArcPro Token                 newToken = arcpy.GetSigninToken()                  # Update the original portalToken                 global portalToken                 portalToken = newToken                  # convert encoded string into python structure and update token                 # by parsing the encoded query strting into list of (name, value pairs)                 # i.e [('f', 'json'),('token','U62uXB9Qcd1xjyX1)]                 # convert to dictionary and update the token in dictionary                  queryString = parseQueryString(params)                  requestDict = dict(queryString)                 requestDict.update(token=newToken['token'])                  newParams = urllibEncode(requestDict)                 newParams = newParams.encode('ascii')                  # update incoming parameters just in case a 2nd attempt is needed                 INparams = newParams                  resp = urllib.request.urlopen(url,newParams)  # A failure here will probably throw an HTTP exception                  responseStatus = resp.getcode()                 responseMsg = resp.msg                 jsonString = resp.read()                  results = json.loads(jsonString)          # Check results before returning them; Attempt a 2nd request if results are bad.         if 'error' in results.keys() or len(results) == 0:             time.sleep(5)             resp = urllib.request.urlopen(url,INparams)  # A failure here will probably throw an HTTP exception              responseStatus = resp.getcode()             responseMsg = resp.msg             jsonString = resp.read()              results = json.loads(jsonString)              if 'error' in results.keys() or len(results) == 0:                 AddMsgAndPrint("\t2nd Request Attempt Failed - Error Code: " + str(responseStatus) + " -- " + responseMsg + " -- " + str(results),2)                 return False             else:                 return results          else:              return results      except httpErrors as e:          if int(e.code) >= 500:            #AddMsgAndPrint("\n\t\tHTTP ERROR: " + str(e.code) + " ----- Server side error. Probably exceed JSON imposed limit",2)            #AddMsgAndPrint("t\t" + str(request))            pass         elif int(e.code) >= 400:            #AddMsgAndPrint("\n\t\tHTTP ERROR: " + str(e.code) + " ----- Client side error. Check the following SDA Query for errors:",2)            #AddMsgAndPrint("\t\t" + getGeometryQuery)            pass         else:            AddMsgAndPrint('HTTP ERROR = ' + str(e.code),2)      except:         errorMsg()         return False
fsMetadata = submitFSquery(cluRESTurl_Metadata,params)
from importlib import reload
aprx = arcpy.mp.ArcGISProject("CURRENT")
aprx.homeFolder
aprx
map = aprx.listMaps()[0]
map
map.name
fm = arcpy.FieldMap()
fms = arcpy.FieldMappings()
fm.outputField
clu = map.listLayers("CLU_in091*")[0]
clu
clu.name
for field in arcpy.ListFields(clu):     fm.addInputField(clu, field.name)
clu = r'C:\Determinations\in091_t0012564_2020_09\in091_t0012564_2020_09_BaseData.gdb\CLU_in091_t0012564_2020_09'
for field in arcpy.ListFields(clu):     fm.addInputField(clu, field.name)
del fm
fm = arcpy.FieldMap()
for field in arcpy.ListFields(clu):     fm.addInputField(clu, field.name)
for field in arcpy.ListFields(clu):     print(field.name)
for field in arcpy.ListFields(clu):     fm.addInputField(clu, field.name)
fm
fm.removeAll()
fm
for field in arcpy.ListFields(clu):     fm.addInputField(clu, field.name)
import arcpy
for field in arcpy.ListFields(clu):     fm.addInputField(clu, field.name)
fm.removeAll()
del fm
del fms
fm_clu = arcpy.FieldMap()
fm_clu.addInputField(clu, "admin_state")
fm_clu.getInputFieldName()[0]
fm_clu.getInputFieldName()
fm_clu.getInputFieldName(0)
aprx
aprx = arcpy.mp.ArcGISProject("CURRENT")
map_name = "Determinations"
activeMap = aprx.listMaps(map_name)[0]
activeMap
activeMap.spatialReference
activeMap.spatialReference.name
clu = r'C:\Determinations\in091_t0012564_2020_09\in091_t0012564_2020_09_BaseData.gdb\Layers\CLU_in091_t0012564_2020_09'
arcpy.Exists(clu)
fm = arcpy.FieldMap()
for field in arcpy.ListFields(clu):     fm.addInputField(clu, field.name)
for field in arcpy.ListFields(clu, '*'):     fm.addInputField(clu, field.name)
fm.inputFieldCount
fm.getInputFieldName(0)
fm.getInputFieldName(1)
fm.getInputFieldName(2)
fm.removeAll()
fm.inputFieldCount
del fm
fm = arcpy.FieldMap()
fm.inputFieldCount
fields = arcpy.listFields(clu, "*")
fields = arcpy.ListFields(clu, "*")
for field in fields:     fm.addInputField(clu, field.name)
fm.inputFieldCount
fm.getInputFieldName(0)
fm.removeAll()
for field in fields:     print(field.name)
for field in fields:     if field.name == "OBJECTID":         fields.remove(field)
for field in fields:     if field.name == "Shape":         fields.remove(field)
for field in fields:     print(field.name)
for field in fields:     fm.addInputField(clu, field.name)
fm.getInputFieldName(10)
fm.inputFieldCount
x = 0
while x <= 32:     fm.getInputFieldName(x)     x += 1
map
aprx
my_map = aprx.listMaps("*Det*")[0]
my_map
my_mapSR = activeMap.getDefinition('V2').spatialReference['latestWkid']
my_mapSR.name
sr = arcpy.SpatialReference(my_mapSR)
sr.name
activeMap
definition = activeMap.getDefinition('V2')
tr = definition.datumTransforms
del tr
sr = definition.spatialReference
sr
tr = definition.datumTransforms
tr
sr = activeMap.spatialReference
sr.name
trs = definition.datumTransforms
trs
trs0 = trs[0]
trs0.geoTransformation
trs1 = trs[1]
trs1
trs1.name
trs1.geoTransformation
trs2 = trs[2]
trs2.geoTransformation
versionFlt = 10.6
test = False
if versionFlt >= 10.6:     test = True
test
aprx = arcpy.mp.ArcGISProject("CURRENT")
m = aprx.listMaps("Determinations")[0]
m
m.name
sun = m.listLayers("Sampling Units New")[0]
sun.name
sud = m.listLayers("sampling_units_dissolve")
sun = r'C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\Conversions.gdb\sampling_units'
sud = r'C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\Conversions.gdb\sampling_units_dissolve'
arcpy.Exists(sun)
arcpy.Exists(sud)
sud_cursor = arcpy.da.SearchCursor(sud)
sud_cursor = arcpy.da.SearchCursor(sud, '*')
x = 0
sud_cursor.fields
for row in sud_cursor:     print(row[5])     break
sud_cursor = arcpy.da.SearchCursor(sud, '*')
aprx = arcpy.mp.ArcGISProject("CURRENT")
map = aprx.listMaps("*Determinations*")[0]
map.name
deflyrs = map.listLayers("*Define_AOI_*")
for lyr in deflyrs:     print(lyr.name)
apr
aprx
aprx = arcpy.mp.ArcGISProject("CURRENT")
map = aprx.listMaps()[0]
map.name
for lyr in map.listLayers():     print(lyr.name)
anno_lyr = map.listLayers("*09Anno*")[0]
anno_lyr.name
anno_lyr.visible = False
anno_lyr.visible = True
arcpy.env.workspace
aprx.defaultGeodatabase
aprx.defaultGeodatabase = r'C:\Determinations\in091_t0012564_2020_09\in091_t0012564_2020_09_BaseData.gdb'
s_path = r'C:\GIS_Tools\NRCS_Wetland_Tools\Pro\SUPPORT'
import o
import os
os.path.dirname(s_path)
s_path = r'C:\GIS_Tools\NRCS_Wetland_Tools\Pro\SUPPORT\create_project.py'
os.path.dirname(s_path)
os.path.join(os.path.dirname(s_path), "SUPPORT.gdb")
arcpy.Exists(os.path.join(os.path.dirname(s_path), "SUPPORT.gdb"))
s_path = r'C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\create_project.py'
arcpy.Exists(os.path.join(os.path.dirname(s_path), "SUPPORT.gdb"))
fields = ['first','second']
'three' not in fields
'second' not in fields
import os
aprx = arcpy.mp.ArcGISProject("CURRENT")
map = aprx.listMaps()[0]
map.name
test_lyr = map.listLayers("Certified Wetland Determinations (Server)")[0]
test_lyr.name
desc = arcpy.Describe(test_lyr)
desc.catalogpath
arcpy.Exists("https://gis-staging.usda.net/server/rest/services/Hosted/Certified_Wetland_Determinations_Test_Feature_Layer/FeatureServer/0")
time.strftime('%m/%d/%Y')
time.ctime()
aprx = ararcpy.mp.ArcGISProject("CURRENT")
aprx = arcpy.mp.ArcGISProject("CURRENT")
map = aprx.listMaps("Determinations")[0]
sourceDefine = map.listLayers("*Define_AOI_*")[0]
sourceDefine.name
desc = arcpy.Describe(sourceDefine)
disc.FIDset
desc.FIDset
desc = arcpy.Describe(sourceDefine)
desc.FIDset
sourceDefine_path = arcpy.Describe(sourceDefine).CatalogPath
sourceDefine_path
basedataGDB_path = sourceDefine_path[:sourceDefine_path.find('.gdb')+4]
basedataGDB_path
workspace = basedataGDB_path
edit = arcpy.da.Editor(workspace)
edit.isEditing
basedataGDB_name = os.path.basename(basedataGDB_path)
import os
basedataGDB_name = os.path.basename(basedataGDB_path)
basedataFD = basedataGDB_path + os.sep + "Layers"
userWorkspace = os.path.dirname(basedataGDB_path)
userWorkspace
projectName = os.path.basename(userWorkspace)
projectName
wholeTract = "No"
selectFields = "Yes"
keepFields = "No"
resetROPs = "No"
resetDrains = "No"
existing_cwd = 'https://gis-staging.usda.net/server/rest/services/Hosted/Certified_Wetland_Determinations_Test_Feature_Layer/FeatureServer/0'
wetDir = userWorkspace + os.sep + "Wetlands"
wcGDB_name = os.path.basename(userWorkspace).replace(" ", "_") + "_WC.gdb"
wcGDB_path = wetDir + os.sep + wcGDB_name
wcFD = wcGDB_path + os.sep + "WC_Data"
projectCLU = basedataFD + os.sep + "CLU_" + projectName
projectTract = basedataFD + os.sep + "Tract_" + projectName
projectTractB = basedataFD + os.sep + "Tract_Buffer_" + projectName
projectTable = basedataGDB_path + os.sep + "Table_" + projectName
projectAOI = basedataFD + os.sep + "AOI_" + projectName
projectDAOI = basedataFD + os.sep + "Define_AOI_" + projectName
suTemp1 = "in_memory" + os.sep + "SU_Temp1_" + projectName
suTemp2 = "in_memory" + os.sep + "SU_Temp2_" + projectName
suName = "SU_" + projectName
projectSU = wcFD + os.sep + suName
templateSU = os.path.join(os.path.dirname(sys.argv[0]), "SUPPORT.gdb" + os.sep + "master_sampling_units")
templateSU = r'C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\SUPPORT.gdb\master_sampling_units'
projectROP = wcFD + os.sep + "ROPs_" + projectName
templateROP = r'C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\SUPPORT.gdb\master_rop'
templateLines = r'C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\SUPPORT.gdb\master_drainage_lines'
projectLines = wcFD + os.sep + "Drainage_Lines_" + projectName
extentName = "Extent_" + projectName
projectExtent = basedataFD + os.sep + extentName
extTempName = "Extent_temp1_" + projectName
extentTemp1 = basedataFD + os.sep + extTempName
extentTemp2 = basedataFD + os.sep + "Extent_temp2_" + projectName
extentTemp3 = basedataFD + os.sep + "Extent_temp3_" + projectName
aprx = arcpy.mp.ArcGISProject("CURRENT")
map = aprx.listMaps("Determinations")[0]
suLyr = map.listLayers("*SU_*")[0]
suLyr.name
suLyr.listLayers()
lyr = suLyr.listLayers()[0]
suLyr.visible = False
suLyr.visible = True
su = suLyr.CatalogPath
su = suLyr.CatalogPath()
suLyr.dataSource
su = suLyr.dataSource
arcpy.ListFields('SU_in091_t0012564_2020_09', "*su_number")[0]
su_field = arcpy.ListFields('SU_in091_t0012564_2020_09', "*su_number")[0]
su_field.name
suSym = r"C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\layer_files\Sampling_Units.lyrx"
arcpy.management.ApplySymbologyFromLayer(suLyr, suSym, 'VALUE_FIELD # #', 'MAINTAIN')
suLyr.name
arcpy.management.ApplySymbologyFromLayer(suLyr, suSym)
del suLyr
del su_field
del su
suLyr = map.listLayers("*SU_*")[0]
suLyr.name
suSym
arcpy.management.ApplySymbologyFromLayer(suLyr, suSym)
dlyr = map.listLayers("Define_*")[0]
dlyr.nam
dlyr.name
dlyr.setSelectionSet([], 'NEW')
arcpy.management.SelectLayerByAttribute(dlyr, 'CLEAR_SELECTION')
my_name = dlyr.name
arcpy.management.ApplySymbologyFromLayer('ROPs_in091_t0012564_2020_09', 'ROPs')
drainSym = r"C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\layer_files\Drainage_Lines.lyrx"
arcpy.management.ApplySymbologyFromLayer('Drainage_Lines_in091_t0012564_2020_09', drainSym)
aprx = arcpy.mp.ArcGISProject("CURRENT")
m1 = aprx.listMaps("Determinations")[0]
dLyr = r"C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\layer_files\Drainage_Lines.lyrx"
m1.addLayer(dLyr)
m1.addLayer(dLyr, 'AUTO_ARRANGE')
dLyr
dLyr = arcpy.mp.LayerFile(r"C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\layer_files\Drainage_Lines.lyrx")
m1.addLayer(dLyr)
drainNew = m1.listLayers("*Drainage_Lines*")[0]
drainNew.name
drainNew.dataSource
drainNew.name
drainCIM = drainNew.getDefinition('V2')
dc = drainCIM.featureTable.dataConnection
dc
dc.dataset
dc.featureDataset
drainNew.connectionProperties
dc.workspaceFactory
dc.workspaceConnectionString
shapefile = map.listLayers("AOI")[0]
m1.listLayers("AOI")[0]
shapefile = m1.listLayers("AOI")[0]
shapefile.name
shapeCIM = shapefile.getDefinition('V2')
shapeDC = shapeCIM.featureTable.dataConnection
shapeDC.workspaceConnectionString
my_string = 'DATABASE=Tests'
my_string[9:]
my_string[:9]
new_fc = 'fc2'
cur_lyr = m1.listLayers("*fc1*")[0]
cur_lyr.name
lyrCIM = cur_lyr.getDefinition('V2')
dc = lyrCIM.featureTable.dataConnection
new_ws = r'C:\Temp\Testing2.gdb'
dc.workspaceConnectionString = 'DATABASE=' + new_ws
dc.workspaceConnectionString
dc.dataset = new_fc
cur_lyr.setDefinition(lyrCIM)
aprx = arcpy.mp.ArcGISProject("CURRENT")
m = aprx.listMaps("Determinations")
m = aprx.listMaps("Determinations")[0]
m.name
lyr = arcpy.mp.LayerFile(r"C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\layer_files\Sampling_Units.lyrx")
m.addLayer(lyr)
rlyr = m.listLayers("Sampling Units")[0]
rlyr.catalogpath
rlyr.dataSource
m.removeLayer(rlyr)
bmlyt = aprx.listLayouts("Base Map")[0]
bmlyt.name
bmeles = bmlyt.listElements('LEGEND_ELEMENT')
first_ele = bmeles[0]
arcpy.Describe('LaPorte LiDAR DEM 2013')
arcpy.Describe('LaPorte LiDAR DEM 2013').SpatialReference
arcpy.Describe('LaPorte LiDAR DEM 2013').SpatialReference.name
cluDesc = arcpy.Describe('CLU_in091_t0012564_2020_09')
cluDesc.extent
cluDesc.featureTyp
cluDesc.featureType
cluDesc.extent.XMin
cluDesc.Extent.XMin
gdb = r"C:\Determinations\in091_t0012564_2020_09\Wetlands\in091_t0012564_2020_09_WC.gdb"
arcpy.AlterDomain_management(gdb, "CWD Status", "", "", 'DUPLICATE')
arcpy.management.ApplySymbologyFromLayer('Slope_Pct_in091_t0012564_2020_09', r'C:\GIS_Tools\NRCS_Wetland_Tools_Pro\SUPPORT\layer_files\Slope_Pct.lyrx', 'VALUE_FIELD', 'MAINTAIN')
arcpy.Exists("https://gis-staging.usda.net/server/rest/services/Hosted/Certified_Wetland_Determinations_Test_Feature_Layer/FeatureServer/0")
arcpy.Exists("string")
layout
aprx = arcpy.mp.ArcGISProject("CURRENT")
layout = aprx.listLayouts("Base Map")[0]
legend = layout.listElements('LEGEND_ELEMENT', "BM Legend")[0]
legend.type
Farm_ele = layout.listElements('TEXT_ELEMENT',"BM Farm")[0]
layout.name
if layout:
layout
if layout:     print("Yep")
